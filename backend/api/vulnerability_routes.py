"""
Enhanced Vulnerability Assessment API Routes
"""
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field
from typing import Dict, Any, List, Optional
import logging
import asyncio

from agents.vulnerability_agent import VulnerabilityAgent
from utils.cache_manager import cache_manager
from utils.ethical_boundaries import ethical_boundaries

# Create router instance
router = APIRouter()
logger = logging.getLogger(__name__)
vulnerability_agent = VulnerabilityAgent()

class VulnerabilityScanRequest(BaseModel):
    target: str = Field(..., description="Target for vulnerability scanning")
    scan_profile: str = Field(default="comprehensive", description="Scan profile: quick, comprehensive, deep")
    vulnerability_categories: Optional[List[str]] = Field(default=None, description="Specific vulnerability categories")
    severity_levels: Optional[List[str]] = Field(default=None, description="Severity levels to include")
    custom_templates: Optional[List[str]] = Field(default=None, description="Custom vulnerability templates")

class CVEAnalysisRequest(BaseModel):
    cve_ids: List[str] = Field(..., description="List of CVE IDs to analyze")
    include_exploits: bool = Field(default=False, description="Include exploit information")
    include_patches: bool = Field(default=True, description="Include patch information")

class SecurityConfigRequest(BaseModel):
    target: str = Field(..., description="Target to analyze security configuration")
    config_types: Optional[List[str]] = Field(default=None, description="Types of configuration to analyze")

class ComplianceRequest(BaseModel):
    target: str = Field(..., description="Target for compliance checking")
    frameworks: List[str] = Field(..., description="Compliance frameworks to check against")
    scan_results: Optional[Dict[str, Any]] = Field(default=None, description="Previous scan results")

class RiskAssessmentRequest(BaseModel):
    vulnerabilities: List[Dict[str, Any]] = Field(..., description="List of identified vulnerabilities")
    business_context: Optional[Dict[str, Any]] = Field(default=None, description="Business context for risk assessment")
    threat_landscape: Optional[Dict[str, Any]] = Field(default=None, description="Current threat landscape information")

@router.post("/vulnerability-scan")
async def vulnerability_scan(request: VulnerabilityScanRequest):
    """Perform comprehensive vulnerability scanning"""
    try:
        # Validate target
        if not await ethical_boundaries.validate_target(request.target):
            raise HTTPException(status_code=400, detail="Invalid or unauthorized target")
        
        # Check cache
        cache_key = f"vuln_scan:{request.target}:{request.scan_profile}"
        cached_result = await cache_manager.get_cached_result("vulnerability_scan", request.target, {
            "scan_profile": request.scan_profile,
            "categories": request.vulnerability_categories
        })
        
        if cached_result:
            return cached_result
        
        # Execute vulnerability scan using agent
        result = await vulnerability_agent.run_comprehensive_vulnerability_scan(
            target=request.target,
            scan_profile=request.scan_profile,
            categories=request.vulnerability_categories,
            severity_levels=request.severity_levels,
            custom_templates=request.custom_templates
        )
        
        # Add expert analysis
        result["expert_vulnerability_analysis"] = generate_vulnerability_analysis(result)
        
        # Cache result
        await cache_manager.cache_result("vulnerability_scan", request.target, result, {
            "scan_profile": request.scan_profile,
            "categories": request.vulnerability_categories
        }, ttl=3600)  # Cache for 1 hour
        
        return result
        
    except Exception as e:
        logger.error(f"Vulnerability scan error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Vulnerability scan failed: {str(e)}")

def generate_vulnerability_analysis(vulnerability_data: Dict[str, Any]) -> Dict[str, Any]:
    """Generate expert vulnerability analysis"""
    try:
        analysis = {
            "critical_findings": [],
            "common_patterns": [],
            "immediate_actions": [],
            "risk_assessment": {},
            "analysis_source": "expert_system"
        }
        
        vulnerabilities = vulnerability_data.get("vulnerabilities", [])
        cve_matches = vulnerability_data.get("cve_matches", [])
        
        if not vulnerabilities and not cve_matches:
            analysis["risk_assessment"] = {
                "overall_risk": "low",
                "description": "No significant vulnerabilities detected",
                "action_required": "Routine maintenance"
            }
            return analysis
        
        # Identify critical findings
        critical_vulns = [v for v in vulnerabilities if v.get("severity") == "critical"]
        
        for vuln in critical_vulns[:5]:  # Top 5 critical
            analysis["critical_findings"].append({
                "name": vuln.get("name", "Unknown"),
                "severity": "critical",
                "cvss_score": vuln.get("cvss_score", 0),
                "description": vuln.get("description", ""),
                "immediate_action": "Requires immediate patching or mitigation"
            })
        
        # Analyze CVE matches
        high_cvss_cves = [cve for cve in cve_matches if cve.get("cvss_score", 0) >= 7.0]
        if high_cvss_cves:
            analysis["critical_findings"].append({
                "type": "high_cvss_cves",
                "count": len(high_cvss_cves),
                "description": f"{len(high_cvss_cves)} CVEs with CVSS score >= 7.0 detected",
                "immediate_action": "Review and patch high-severity CVEs"
            })
        
        # Identify common patterns
        severity_counts = {}
        vulnerability_types = {}
        
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "medium")
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
            vuln_type = vuln.get("type", "unknown")
            vulnerability_types[vuln_type] = vulnerability_types.get(vuln_type, 0) + 1
        
        analysis["common_patterns"] = [
            f"{severity}: {count} vulnerabilities" for severity, count in severity_counts.items()
        ]
        
        # Add vulnerability type patterns
        for vuln_type, count in vulnerability_types.items():
            if count > 2:  # Only show patterns with multiple occurrences
                analysis["common_patterns"].append(f"Multiple {vuln_type} vulnerabilities detected ({count})")
        
        # Risk assessment
        total_vulns = len(vulnerabilities)
        critical_count = severity_counts.get("critical", 0)
        high_count = severity_counts.get("high", 0)
        
        if critical_count > 0:
            overall_risk = "critical"
            action_required = "Immediate action required - critical vulnerabilities present"
        elif high_count > 2:
            overall_risk = "high"
            action_required = "High priority remediation needed"
        elif high_count > 0:
            overall_risk = "medium"
            action_required = "Medium priority security improvements needed"
        else:
            overall_risk = "low"
            action_required = "Routine security maintenance"
        
        analysis["risk_assessment"] = {
            "overall_risk": overall_risk,
            "total_vulnerabilities": total_vulns,
            "severity_breakdown": severity_counts,
            "action_required": action_required
        }
        
        # Immediate actions
        if critical_count > 0:
            analysis["immediate_actions"].extend([
                "Patch critical vulnerabilities within 24 hours",
                "Isolate affected systems if possible",
                "Activate security incident response",
                "Document all vulnerabilities and actions"
            ])
        
        if high_count > 0:
            analysis["immediate_actions"].extend([
                "Schedule high-priority patches within 1 week",
                "Implement temporary mitigations",
                "Review access controls and monitoring"
            ])
        
        return analysis
        
    except Exception as e:
        logger.error(f"Vulnerability analysis error: {str(e)}")
        return {"error": "Analysis generation failed", "analysis_source": "expert_system"}

@router.post("/cve-analysis")
async def cve_analysis(request: CVEAnalysisRequest):
    """Analyze CVEs for detailed information"""
    try:
        result = await vulnerability_agent.analyze_cves_detailed(
            cve_ids=request.cve_ids,
            include_exploits=request.include_exploits,
            include_patches=request.include_patches
        )
        
        # Add expert threat analysis
        result["expert_threat_analysis"] = generate_cve_threat_analysis(result)
        
        return result
        
    except Exception as e:
        logger.error(f"CVE analysis error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"CVE analysis failed: {str(e)}")

def generate_cve_threat_analysis(cve_data: Dict[str, Any]) -> Dict[str, Any]:
    """Generate expert CVE threat analysis"""
    try:
        analysis = {
            "threat_summary": {},
            "exploitation_likelihood": {},
            "priority_cves": [],
            "mitigation_strategies": [],
            "analysis_source": "expert_system"
        }
        
        cve_matches = cve_data.get("cve_matches", [])
        
        if not cve_matches:
            analysis["threat_summary"] = {
                "level": "low",
                "description": "No significant CVE threats identified"
            }
            return analysis
        
        # Categorize by CVSS scores
        critical_cves = [cve for cve in cve_matches if cve.get("cvss_score", 0) >= 9.0]
        high_cves = [cve for cve in cve_matches if 7.0 <= cve.get("cvss_score", 0) < 9.0]
        medium_cves = [cve for cve in cve_matches if 4.0 <= cve.get("cvss_score", 0) < 7.0]
        
        # Threat summary
        if critical_cves:
            threat_level = "critical"
            threat_desc = f"{len(critical_cves)} critical CVEs requiring immediate attention"
        elif high_cves:
            threat_level = "high"
            threat_desc = f"{len(high_cves)} high-severity CVEs identified"
        elif medium_cves:
            threat_level = "medium"
            threat_desc = f"{len(medium_cves)} medium-severity CVEs detected"
        else:
            threat_level = "low"
            threat_desc = "Low severity CVEs identified"
        
        analysis["threat_summary"] = {
            "level": threat_level,
            "description": threat_desc,
            "total_cves": len(cve_matches),
            "breakdown": {
                "critical": len(critical_cves),
                "high": len(high_cves),
                "medium": len(medium_cves),
                "low": len([cve for cve in cve_matches if cve.get("cvss_score", 0) < 4.0])
            }
        }
        
        # Priority CVEs (top 5 most critical)
        sorted_cves = sorted(cve_matches, key=lambda x: x.get("cvss_score", 0), reverse=True)
        for cve in sorted_cves[:5]:
            analysis["priority_cves"].append({
                "cve_id": cve.get("cve_id"),
                "cvss_score": cve.get("cvss_score"),
                "severity": cve.get("severity"),
                "description": cve.get("description", "")[:200] + "..." if len(cve.get("description", "")) > 200 else cve.get("description", ""),
                "priority_reason": f"CVSS Score: {cve.get('cvss_score')}"
            })
        
        # Exploitation likelihood assessment
        analysis["exploitation_likelihood"] = {
            "overall": "high" if threat_level in ["critical", "high"] else "medium",
            "factors": [
                "Public exploit availability" if any(cve.get("exploit_available", False) for cve in cve_matches) else "Limited exploit availability",
                f"{len(cve_matches)} CVEs increase attack surface",
                "Recent CVEs indicate active threat landscape" if any((datetime.now() - datetime.fromisoformat(cve.get("published_date", datetime.now().isoformat()))).days < 90 for cve in cve_matches) else "Established threat landscape"
            ]
        }
        
        # Mitigation strategies
        if critical_cves:
            analysis["mitigation_strategies"].extend([
                "Immediately patch all critical CVEs",
                "Implement virtual patching if immediate patching not possible",
                "Isolate affected systems until patched",
                "Monitor for exploitation attempts"
            ])
        
        if high_cves:
            analysis["mitigation_strategies"].extend([
                "Schedule high-priority patching within 72 hours",
                "Implement compensating controls",
                "Increase monitoring and logging",
                "Review and update intrusion detection signatures"
            ])
        
        analysis["mitigation_strategies"].extend([
            "Subscribe to CVE feeds for ongoing monitoring",
            "Establish vulnerability management process",
            "Regular security assessments and penetration testing",
            "Maintain asset inventory for targeted patching"
        ])
        
        return analysis
        
    except Exception as e:
        logger.error(f"CVE threat analysis error: {str(e)}")
        return {"error": "Analysis generation failed", "analysis_source": "expert_system"}

@router.post("/security-config-analysis")
async def security_config_analysis(request: SecurityConfigRequest):
    """Analyze security configuration issues"""
    try:
        # Validate target
        if not await ethical_boundaries.validate_target(request.target):
            raise HTTPException(status_code=400, detail="Invalid or unauthorized target")
        
        result = await vulnerability_agent.analyze_security_configuration(
            target=request.target,
            config_types=request.config_types or ["ssl", "headers", "cookies", "general"]
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Security config analysis error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Security configuration analysis failed: {str(e)}")

@router.post("/compliance-check")
async def compliance_check(request: ComplianceRequest):
    """Check compliance against security frameworks"""
    try:
        result = await vulnerability_agent.check_compliance(
            target=request.target,
            frameworks=request.frameworks,
            previous_scan_results=request.scan_results
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Compliance check error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Compliance check failed: {str(e)}")

@router.post("/risk-assessment")
async def risk_assessment(request: RiskAssessmentRequest):
    """Perform comprehensive risk assessment"""
    try:
        result = await vulnerability_agent.perform_comprehensive_risk_assessment(
            vulnerabilities=request.vulnerabilities,
            business_context=request.business_context,
            threat_landscape=request.threat_landscape
        )
        
        # Add expert risk analysis
        result["expert_risk_analysis"] = generate_risk_analysis(result)
        
        return result
        
    except Exception as e:
        logger.error(f"Risk assessment error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Risk assessment failed: {str(e)}")

def generate_risk_analysis(risk_data: Dict[str, Any]) -> Dict[str, Any]:
    """Generate expert risk analysis"""
    try:
        analysis = {
            "risk_scenario_analysis": {},
            "threat_actor_assessment": {},
            "business_impact_projection": {},
            "risk_mitigation_priorities": [],
            "analysis_source": "expert_system"
        }
        
        # Risk scenario analysis
        overall_risk = risk_data.get("overall_risk_level", "medium")
        risk_score = risk_data.get("risk_score", 0)
        
        analysis["risk_scenario_analysis"] = {
            "current_risk_level": overall_risk,
            "risk_score": risk_score,
            "scenario_description": f"Security posture indicates {overall_risk} risk level",
            "time_to_exploit": "1-7 days" if overall_risk in ["critical", "high"] else "1-4 weeks",
            "attack_complexity": "Low" if overall_risk in ["critical", "high"] else "Medium"
        }
        
        # Threat actor assessment based on vulnerabilities
        vulnerabilities = risk_data.get("vulnerabilities", [])
        severity_breakdown = risk_data.get("severity_breakdown", {})
        
        threat_actors = []
        if severity_breakdown.get("critical", 0) > 0:
            threat_actors.extend([
                "Advanced Persistent Threats (APTs)",
                "Organized cybercrime groups",
                "Nation-state actors"
            ])
        
        if severity_breakdown.get("high", 0) > 2:
            threat_actors.extend([
                "Experienced cybercriminals",
                "Hacktivist groups",
                "Malicious insiders"
            ])
        
        if severity_breakdown.get("medium", 0) > 5:
            threat_actors.extend([
                "Opportunistic attackers",
                "Script kiddies",
                "Automated attack tools"
            ])
        
        analysis["threat_actor_assessment"] = {
            "likely_threat_actors": list(set(threat_actors)) if threat_actors else ["Low-skill opportunistic attackers"],
            "motivation": "Financial gain, data theft, or disruption" if overall_risk in ["critical", "high"] else "Opportunistic targeting",
            "capability_assessment": "High capability with advanced tools" if severity_breakdown.get("critical", 0) > 0 else "Moderate capability"
        }
        
        # Business impact projection
        total_issues = risk_data.get("total_issues", 0)
        
        if overall_risk == "critical":
            business_impact = {
                "financial_impact": "$500K - $2M",
                "operational_disruption": "Severe - potential business halt",
                "reputation_damage": "Significant and long-lasting",
                "regulatory_fines": "$100K - $1M",
                "recovery_time": "2-8 weeks"
            }
        elif overall_risk == "high":
            business_impact = {
                "financial_impact": "$100K - $500K",
                "operational_disruption": "Major - significant impact",
                "reputation_damage": "Moderate to significant",
                "regulatory_fines": "$50K - $500K",
                "recovery_time": "1-4 weeks"
            }
        elif overall_risk == "medium":
            business_impact = {
                "financial_impact": "$10K - $100K",
                "operational_disruption": "Moderate - manageable impact",
                "reputation_damage": "Minor to moderate",
                "regulatory_fines": "$10K - $50K",
                "recovery_time": "3-14 days"
            }
        else:
            business_impact = {
                "financial_impact": "$1K - $10K",
                "operational_disruption": "Minor - minimal impact",
                "reputation_damage": "Minimal",
                "regulatory_fines": "$1K - $10K",
                "recovery_time": "1-3 days"
            }
        
        analysis["business_impact_projection"] = business_impact
        
        # Risk mitigation priorities
        if severity_breakdown.get("critical", 0) > 0:
            analysis["risk_mitigation_priorities"].extend([
                "IMMEDIATE: Patch all critical vulnerabilities within 24 hours",
                "EMERGENCY: Implement virtual patching for critical systems",
                "URGENT: Isolate critical systems if patching not possible",
                "CRITICAL: Activate incident response procedures"
            ])
        
        if severity_breakdown.get("high", 0) > 2:
            analysis["risk_mitigation_priorities"].extend([
                "HIGH: Patch high-severity vulnerabilities within 72 hours",
                "IMPORTANT: Implement compensating controls",
                "PRIORITY: Enhance monitoring and detection capabilities"
            ])
        
        analysis["risk_mitigation_priorities"].extend([
            "MEDIUM: Develop comprehensive vulnerability management process",
            "ONGOING: Regular security assessments and penetration testing",
            "STRATEGIC: Implement defense-in-depth security architecture",
            "COMPLIANCE: Ensure regulatory requirements are met"
        ])
        
        return analysis
        
    except Exception as e:
        logger.error(f"Risk analysis error: {str(e)}")
        return {"error": "Analysis generation failed", "analysis_source": "expert_system"}

@router.post("/generate-vulnerability-report")
async def generate_vulnerability_report(report_request: Dict[str, Any]):
    """Generate comprehensive vulnerability report"""
    try:
        scan_results = report_request.get("scan_results")
        report_format = report_request.get("format", "detailed")
        include_recommendations = report_request.get("include_recommendations", True)
        
        if not scan_results:
            raise HTTPException(status_code=400, detail="Scan results required")
        
        report = await vulnerability_agent.generate_vulnerability_report(
            scan_results=scan_results,
            format=report_format,
            include_recommendations=include_recommendations
        )
        
        return {
            "report": report,
            "format": report_format,
            "generated_at": asyncio.get_event_loop().time()
        }
        
    except Exception as e:
        logger.error(f"Generate vulnerability report error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to generate vulnerability report: {str(e)}")

@router.get("/vulnerability-databases")
async def get_vulnerability_databases():
    """Get connected vulnerability databases"""
    databases = {
        "cve_database": {
            "name": "CVE Database",
            "status": "connected",
            "last_update": "2024-01-15",
            "vulnerabilities_count": 200000
        },
        "exploit_db": {
            "name": "Exploit Database",
            "status": "connected",
            "last_update": "2024-01-14",
            "exploits_count": 45000
        },
        "vulndb": {
            "name": "VulnDB",
            "status": "connected",
            "last_update": "2024-01-15",
            "vulnerabilities_count": 300000
        }
    }
    
    return {"vulnerability_databases": databases}

@router.post("/custom-vulnerability-check")
async def custom_vulnerability_check(check_request: Dict[str, Any]):
    """Perform custom vulnerability checks"""
    try:
        target = check_request.get("target")
        custom_checks = check_request.get("custom_checks", [])
        
        if not target or not custom_checks:
            raise HTTPException(status_code=400, detail="Target and custom checks required")
        
        result = await vulnerability_agent.perform_custom_vulnerability_checks(
            target=target,
            custom_checks=custom_checks
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Custom vulnerability check error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Custom vulnerability check failed: {str(e)}")

@router.get("/severity-levels")
async def get_severity_levels():
    """Get vulnerability severity level definitions"""
    severity_levels = {
        "critical": {
            "cvss_range": "9.0 - 10.0",
            "description": "Critical severity vulnerabilities",
            "action_required": "Immediate action required",
            "color": "red"
        },
        "high": {
            "cvss_range": "7.0 - 8.9",
            "description": "High severity vulnerabilities",
            "action_required": "Action required within 24-48 hours",
            "color": "orange"
        },
        "medium": {
            "cvss_range": "4.0 - 6.9",
            "description": "Medium severity vulnerabilities",
            "action_required": "Action required within 1-2 weeks",
            "color": "yellow"
        },
        "low": {
            "cvss_range": "0.1 - 3.9",
            "description": "Low severity vulnerabilities",
            "action_required": "Action recommended during next maintenance",
            "color": "blue"
        },
        "info": {
            "cvss_range": "0.0",
            "description": "Informational findings",
            "action_required": "No immediate action required",
            "color": "green"
        }
    }
    
    return {"severity_levels": severity_levels}

@router.post("/vulnerability-trends")
async def get_vulnerability_trends(trend_request: Dict[str, Any]):
    """Get vulnerability trends and statistics"""
    try:
        target = trend_request.get("target")
        time_period = trend_request.get("time_period", "30d")
        vulnerability_types = trend_request.get("vulnerability_types", [])
        
        trends = await vulnerability_agent.analyze_vulnerability_trends(
            target=target,
            time_period=time_period,
            vulnerability_types=vulnerability_types
        )
        
        return trends
        
    except Exception as e:
        logger.error(f"Vulnerability trends error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to analyze vulnerability trends: {str(e)}")

@router.post("/patch-prioritization")
async def get_patch_prioritization(prioritization_request: Dict[str, Any]):
    """Get patch prioritization recommendations"""
    try:
        vulnerabilities = prioritization_request.get("vulnerabilities", [])
        business_context = prioritization_request.get("business_context", {})
        available_resources = priorititization_request.get("available_resources", {})
        
        if not vulnerabilities:
            raise HTTPException(status_code=400, detail="Vulnerabilities required for prioritization")
        
        prioritization = await vulnerability_agent.generate_patch_prioritization(
            vulnerabilities=vulnerabilities,
            business_context=business_context,
            available_resources=available_resources
        )
        
        # Add expert prioritization analysis
        prioritization["expert_prioritization"] = generate_patch_prioritization_analysis(prioritization)
        
        return prioritization
        
    except Exception as e:
        logger.error(f"Patch prioritization error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to generate patch prioritization: {str(e)}")

def generate_patch_prioritization_analysis(prioritization_data: Dict[str, Any]) -> Dict[str, Any]:
    """Generate expert patch prioritization analysis"""
    try:
        analysis = {
            "prioritization_strategy": {},
            "resource_allocation": {},
            "timeline_recommendations": [],
            "risk_factors": [],
            "analysis_source": "expert_system"
        }
        
        critical_patches = prioritization_data.get("critical", [])
        high_patches = prioritization_data.get("high", [])
        medium_patches = prioritization_data.get("medium", [])
        
        # Prioritization strategy
        if critical_patches:
            analysis["prioritization_strategy"] = {
                "approach": "Emergency patching protocol",
                "focus": "Critical vulnerabilities first",
                "justification": f"{len(critical_patches)} critical vulnerabilities require immediate attention"
            }
        elif high_patches:
            analysis["prioritization_strategy"] = {
                "approach": "Risk-based prioritization",
                "focus": "High-impact vulnerabilities",
                "justification": f"{len(high_patches)} high-severity vulnerabilities identified"
            }
        else:
            analysis["prioritization_strategy"] = {
                "approach": "Maintenance schedule integration",
                "focus": "Efficiency and minimal disruption",
                "justification": "Medium and low severity vulnerabilities allow for planned maintenance"
            }
        
        # Resource allocation recommendations
        total_patches = len(critical_patches) + len(high_patches) + len(medium_patches)
        
        if total_patches > 20:
            analysis["resource_allocation"] = {
                "team_size": "4-6 security professionals",
                "time_estimate": "2-4 weeks",
                "specialized_tools": "Vulnerability management platform, automated patching tools",
                "coordination": "Cross-team coordination required"
            }
        elif total_patches > 10:
            analysis["resource_allocation"] = {
                "team_size": "2-3 security professionals",
                "time_estimate": "1-2 weeks",
                "specialized_tools": "Standard patching tools, monitoring systems",
                "coordination": "IT operations team coordination"
            }
        else:
            analysis["resource_allocation"] = {
                "team_size": "1-2 security professionals",
                "time_estimate": "3-7 days",
                "specialized_tools": "Basic patching tools",
                "coordination": "Minimal coordination required"
            }
        
        # Timeline recommendations
        if critical_patches:
            analysis["timeline_recommendations"].extend([
                "Phase 1 (0-24h): Patch all critical vulnerabilities",
                "Phase 2 (24-72h): Address remaining critical issues",
                "Phase 3 (3-7 days): Patch high-severity vulnerabilities",
                "Phase 4 (1-2 weeks): Complete medium and low priority patches"
            ])
        elif high_patches:
            analysis["timeline_recommendations"].extend([
                "Phase 1 (0-72h): Patch high-severity vulnerabilities",
                "Phase 2 (3-7 days): Address medium-severity issues",
                "Phase 3 (1-2 weeks): Complete low-priority patches"
            ])
        else:
            analysis["timeline_recommendations"].extend([
                "Phase 1 (1 week): Patch medium-severity vulnerabilities",
                "Phase 2 (2 weeks): Complete low-priority patches",
                "Phase 3 (Ongoing): Establish regular patching schedule"
            ])
        
        # Risk factors
        if critical_patches:
            analysis["risk_factors"].extend([
                "Business disruption during critical patching",
                "System instability from emergency patches",
                "Resource availability for 24/7 patching effort"
            ])
        
        analysis["risk_factors"].extend([
            "Patch compatibility issues with existing systems",
            "Service interruptions during maintenance windows",
            "User productivity impact during patching",
            "Third-party dependency coordination challenges"
        ])
        
        return analysis
        
    except Exception as e:
        logger.error(f"Patch prioritization analysis error: {str(e)}")
        return {"error": "Analysis generation failed", "analysis_source": "expert_system"}
vulnerability_router = router