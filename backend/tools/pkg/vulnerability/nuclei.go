package vulnerability

import (
    "context"
    "encoding/json"
    "fmt"
    "os/exec"
    "strings"
    "time"

    "github.com/spf13/cobra"
)

type NucleiResult struct {
    Target          string            `json:"target"`
    Vulnerabilities []VulnerabilityInfo `json:"vulnerabilities"`
    Summary         ScanSummary       `json:"summary"`
    Status          string            `json:"status"`
}

type VulnerabilityInfo struct {
    TemplateID   string            `json:"template_id"`
    Name         string            `json:"name"`
    Severity     string            `json:"severity"`
    Description  string            `json:"description"`
    Reference    []string          `json:"reference"`
    Classification map[string]string `json:"classification"`
    MatchedAt    string            `json:"matched_at"`
    ExtractedResults []string      `json:"extracted_results,omitempty"`
}

type ScanSummary struct {
    Total    int `json:"total"`
    Critical int `json:"critical"`
    High     int `json:"high"`
    Medium   int `json:"medium"`
    Low      int `json:"low"`
    Info     int `json:"info"`
}

func NewVulnCommand() *cobra.Command {
    var target string
    var templates string
    var severity string
    var concurrency int

    cmd := &cobra.Command{
        Use:   "vuln",
        Short: "Vulnerability scanning with Nuclei",
        Run: func(cmd *cobra.Command, args []string) {
            result := performNucleiScan(target, templates, severity, concurrency)
            outputJSON(result)
        },
    }

    cmd.Flags().StringVarP(&target, "target", "t", "", "Target URL or IP")
    cmd.Flags().StringVarP(&templates, "templates", "T", "", "Template or template directory")
    cmd.Flags().StringVarP(&severity, "severity", "s", "critical,high,medium", "Severity levels to scan")
    cmd.Flags().IntVarP(&concurrency, "concurrency", "c", 25, "Number of concurrent requests")
    cmd.MarkFlagRequired("target")

    return cmd
}

func performNucleiScan(target, templates, severity string, concurrency int) NucleiResult {
    result := NucleiResult{
        Target:          target,
        Vulnerabilities: []VulnerabilityInfo{},
        Summary:         ScanSummary{},
        Status:          "running",
    }

    // Prepare nuclei command
    args := []string{
        "-target", target,
        "-json",
        "-silent",
        "-c", fmt.Sprintf("%d", concurrency),
    }

    if templates != "" {
        args = append(args, "-t", templates)
    }

    if severity != "" {
        args = append(args, "-severity", severity)
    }

    ctx, cancel := context.WithTimeout(context.Background(), 15*time.Minute)
    defer cancel()

    cmd := exec.CommandContext(ctx, "nuclei", args...)
    
    output, err := cmd.Output()
    if err != nil {
        result.Status = "error"
        // Add error details for debugging
        if exitError, ok := err.(*exec.ExitError); ok {
            result.Vulnerabilities = append(result.Vulnerabilities, VulnerabilityInfo{
                Name:        "Scan Error",
                Severity:    "info",
                Description: fmt.Sprintf("Nuclei scan failed: %s", string(exitError.Stderr)),
            })
        } else {
            result.Vulnerabilities = append(result.Vulnerabilities, VulnerabilityInfo{
                Name:        "Execution Error",
                Severity:    "info", 
                Description: fmt.Sprintf("Failed to execute nuclei: %v", err),
            })
        }
        return result
    }

    // Parse JSON output
    lines := strings.Split(string(output), "\n")
    for _, line := range lines {
        line = strings.TrimSpace(line)
        if line == "" {
            continue
        }

        var nucleiOutput map[string]interface{}
        if err := json.Unmarshal([]byte(line), &nucleiOutput); err != nil {
            continue
        }

        // Extract vulnerability information
        vuln := VulnerabilityInfo{
            TemplateID:  getString(nucleiOutput, "template-id"),
            Name:        getString(nucleiOutput, "info.name"),
            Severity:    getString(nucleiOutput, "info.severity"),
            Description: getString(nucleiOutput, "info.description"),
            MatchedAt:   getString(nucleiOutput, "matched-at"),
        }

        // Extract references
        if refs, ok := nucleiOutput["info"].(map[string]interface{})["reference"]; ok {
            if refSlice, ok := refs.([]interface{}); ok {
                for _, ref := range refSlice {
                    if refStr, ok := ref.(string); ok {
                        vuln.Reference = append(vuln.Reference, refStr)
                    }
                }
            }
        }

        // Extract classification
        vuln.Classification = make(map[string]string)
        if classification, ok := nucleiOutput["info"].(map[string]interface{})["classification"]; ok {
            if classMap, ok := classification.(map[string]interface{}); ok {
                for key, value := range classMap {
                    if valueStr, ok := value.(string); ok {
                        vuln.Classification[key] = valueStr
                    }
                }
            }
        }

        // Extract extracted results if present
        if extracted, ok := nucleiOutput["extracted-results"]; ok {
            if extractedSlice, ok := extracted.([]interface{}); ok {
                for _, item := range extractedSlice {
                    if itemStr, ok := item.(string); ok {
                        vuln.ExtractedResults = append(vuln.ExtractedResults, itemStr)
                    }
                }
            }
        }

        result.Vulnerabilities = append(result.Vulnerabilities, vuln)
        
        // Update summary
        result.Summary.Total++
        switch strings.ToLower(vuln.Severity) {
        case "critical":
            result.Summary.Critical++
        case "high":
            result.Summary.High++
        case "medium":
            result.Summary.Medium++
        case "low":
            result.Summary.Low++
        case "info":
            result.Summary.Info++
        }
    }

    result.Status = "completed"
    return result
}

func getString(data map[string]interface{}, path string) string {
    keys := strings.Split(path, ".")
    current := data
    
    for i, key := range keys {
        if i == len(keys)-1 {
            if value, ok := current[key].(string); ok {
                return value
            }
            return ""
        }
        
        if next, ok := current[key].(map[string]interface{}); ok {
            current = next
        } else {
            return ""
        }
    }
    
    return ""
}

// Added the missing outputJSON function
func outputJSON(result interface{}) {
    jsonData, _ := json.MarshalIndent(result, "", "  ")
    fmt.Println(string(jsonData))
}