"""
Vulnerability Agent - Vulnerability assessment and CVE analysis
"""
import asyncio
import subprocess
import json
import requests
from typing import Dict, Any, List
from datetime import datetime
from .base_agent import BaseAgent

class VulnerabilityAgent(BaseAgent):
    def __init__(self):
        super().__init__(
            name="vulnerability",
            description="Vulnerability assessment, CVE analysis, and security testing"
        )
        self.cve_api_base = "https://cve.circl.lu/api"
        
    async def execute(self, target: str, options: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute vulnerability assessment phase"""
        if not await self.validate_target(target):
            return {"error": "Invalid target"}
            
        self.status = "running"
        results = {
            "target": target,
            "phase": "vulnerability",
            "vulnerabilities": [],
            "cve_matches": [],
            "security_issues": [],
            "risk_assessment": {},
            "recommendations": []
        }
        
        try:
            # Nuclei vulnerability scanning
            await self.send_update(options.get("websocket_manager"), options.get("client_id"), {
                "status": "nuclei_scanning",
                "message": "Running Nuclei vulnerability scans..."
            })
            results["vulnerabilities"] = await self.run_nuclei_scan(target)
            
            # CVE analysis
            await self.send_update(options.get("websocket_manager"), options.get("client_id"), {
                "status": "cve_analysis",
                "message": "Analyzing CVE database matches..."
            })
            results["cve_matches"] = await self.analyze_cves(target, results["vulnerabilities"])
            
            # Security configuration analysis
            await self.send_update(options.get("websocket_manager"), options.get("client_id"), {
                "status": "security_analysis",
                "message": "Analyzing security configurations..."
            })
            results["security_issues"] = await self.analyze_security_config(target)
            
            # Risk assessment
            await self.send_update(options.get("websocket_manager"), options.get("client_id"), {
                "status": "risk_assessment",
                "message": "Performing risk assessment..."
            })
            results["risk_assessment"] = await self.perform_risk_assessment(results)
            
            # Generate recommendations
            results["recommendations"] = await self.generate_recommendations(results)
            
            self.status = "completed"
            return results
            
        except Exception as e:
            self.status = "error"
            self.log_activity(f"Error during vulnerability assessment: {str(e)}", "error")
            return {"error": str(e)}
    
    async def run_nuclei_scan(self, target: str) -> List[Dict[str, Any]]:
        """Run Nuclei vulnerability scanner"""
        try:
            cmd = [
                "./tools/redstorm-tools", "vuln", 
                "-t", target, 
                "-s", "critical,high,medium",
                "-c", "25"
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd="/app/backend"
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                result = json.loads(stdout.decode())
                return result.get("vulnerabilities", [])
            else:
                self.log_activity(f"Nuclei scan failed: {stderr.decode()}", "error")
                return []
                
        except Exception as e:
            self.log_activity(f"Nuclei scan error: {str(e)}", "error")
            return []
    
    async def analyze_cves(self, target: str, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Analyze CVE database for matches"""
        cve_matches = []
        
        for vuln in vulnerabilities:
            template_id = vuln.get("template_id", "")
            
            # Extract potential CVE IDs from template
            if "cve-" in template_id.lower():
                cve_id = template_id.upper()
                cve_info = await self.fetch_cve_info(cve_id)
                if cve_info:
                    cve_matches.append({
                        "cve_id": cve_id,
                        "cvss_score": cve_info.get("cvss", 0),
                        "severity": self.cvss_to_severity(cve_info.get("cvss", 0)),
                        "description": cve_info.get("summary", ""),
                        "published_date": cve_info.get("Published", ""),
                        "references": cve_info.get("references", []),
                        "affected_template": template_id
                    })
        
        return cve_matches
    
    async def fetch_cve_info(self, cve_id: str) -> Dict[str, Any]:
        """Fetch CVE information from API"""
        try:
            response = requests.get(f"{self.cve_api_base}/cve/{cve_id}", timeout=10)
            if response.status_code == 200:
                return response.json()
        except Exception as e:
            self.log_activity(f"CVE API request failed: {str(e)}", "error")
        
        return {}
    
    def cvss_to_severity(self, cvss_score: float) -> str:
        """Convert CVSS score to severity level"""
        if cvss_score >= 9.0:
            return "critical"
        elif cvss_score >= 7.0:
            return "high"
        elif cvss_score >= 4.0:
            return "medium"
        elif cvss_score > 0:
            return "low"
        else:
            return "info"
    
    async def analyze_security_config(self, target: str) -> List[Dict[str, Any]]:
        """Analyze security configuration issues"""
        security_issues = []
        
        try:
            # Check SSL/TLS configuration
            ssl_issues = await self.check_ssl_config(target)
            security_issues.extend(ssl_issues)
            
            # Check HTTP security headers
            header_issues = await self.check_security_headers(target)
            security_issues.extend(header_issues)
            
            # Check for common misconfigurations
            config_issues = await self.check_common_misconfigs(target)
            security_issues.extend(config_issues)
            
        except Exception as e:
            self.log_activity(f"Security config analysis failed: {str(e)}", "error")
        
        return security_issues
    
    async def check_ssl_config(self, target: str) -> List[Dict[str, Any]]:
        """Check SSL/TLS configuration"""
        ssl_issues = []
        
        try:
            url = f"https://{target}" if not target.startswith("http") else target
            response = requests.get(url, timeout=10, verify=False)
            
            # Check for HTTPS redirect
            if not url.startswith("https://"):
                ssl_issues.append({
                    "type": "ssl_config",
                    "issue": "No HTTPS redirect",
                    "severity": "medium",
                    "description": "Site does not redirect HTTP to HTTPS"
                })
            
            # Check certificate validity (simplified)
            ssl_issues.append({
                "type": "ssl_config",
                "issue": "Certificate analysis needed",
                "severity": "info",
                "description": "Manual certificate validation recommended"
            })
            
        except Exception:
            ssl_issues.append({
                "type": "ssl_config",
                "issue": "SSL/TLS not available",
                "severity": "high",
                "description": "Target does not support HTTPS"
            })
        
        return ssl_issues
    
    async def check_security_headers(self, target: str) -> List[Dict[str, Any]]:
        """Check HTTP security headers"""
        header_issues = []
        
        try:
            url = f"https://{target}" if not target.startswith("http") else target
            response = requests.get(url, timeout=10, verify=False)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                "X-Frame-Options": "medium",
                "X-Content-Type-Options": "low",
                "X-XSS-Protection": "medium",
                "Strict-Transport-Security": "high",
                "Content-Security-Policy": "high"
            }
            
            for header, severity in security_headers.items():
                if header not in headers:
                    header_issues.append({
                        "type": "missing_header",
                        "issue": f"Missing {header} header",
                        "severity": severity,
                        "description": f"Security header {header} is not present"
                    })
            
        except Exception as e:
            self.log_activity(f"Security headers check failed: {str(e)}", "error")
        
        return header_issues
    
    async def check_common_misconfigs(self, target: str) -> List[Dict[str, Any]]:
        """Check for common misconfigurations"""
        config_issues = []
        
        # Common paths to check
        common_paths = [
            "/.git/config",
            "/admin",
            "/backup",
            "/.env",
            "/config.php",
            "/phpinfo.php"
        ]
        
        try:
            base_url = f"https://{target}" if not target.startswith("http") else target
            
            for path in common_paths:
                try:
                    response = requests.get(f"{base_url}{path}", timeout=5, verify=False)
                    if response.status_code == 200:
                        config_issues.append({
                            "type": "exposed_file",
                            "issue": f"Exposed sensitive file: {path}",
                            "severity": "high" if path in ["/.git/config", "/.env"] else "medium",
                            "description": f"Sensitive file {path} is publicly accessible"
                        })
                except Exception:
                    continue
                    
        except Exception as e:
            self.log_activity(f"Misconfiguration check failed: {str(e)}", "error")
        
        return config_issues
    
    async def perform_risk_assessment(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Perform overall risk assessment"""
        vulnerabilities = results.get("vulnerabilities", [])
        cve_matches = results.get("cve_matches", [])
        security_issues = results.get("security_issues", [])
        
        # Count by severity
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "info").lower()
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        for cve in cve_matches:
            severity = cve.get("severity", "info").lower()
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        for issue in security_issues:
            severity = issue.get("severity", "info").lower()
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        # Calculate overall risk score
        risk_score = (
            severity_counts["critical"] * 10 +
            severity_counts["high"] * 7 +
            severity_counts["medium"] * 4 +
            severity_counts["low"] * 1
        )
        
        # Determine risk level
        if risk_score >= 50:
            risk_level = "critical"
        elif risk_score >= 25:
            risk_level = "high"
        elif risk_score >= 10:
            risk_level = "medium"
        else:
            risk_level = "low"
        
        return {
            "overall_risk_level": risk_level,
            "risk_score": risk_score,
            "severity_breakdown": severity_counts,
            "total_issues": sum(severity_counts.values()),
            "assessment_date": datetime.now().isoformat()
        }
    
    async def generate_recommendations(self, results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate security recommendations"""
        recommendations = []
        
        vulnerabilities = results.get("vulnerabilities", [])
        security_issues = results.get("security_issues", [])
        risk_assessment = results.get("risk_assessment", {})
        
        # High-priority recommendations
        if risk_assessment.get("overall_risk_level") in ["critical", "high"]:
            recommendations.append({
                "priority": "critical",
                "category": "immediate_action",
                "title": "Immediate Security Review Required",
                "description": "Critical vulnerabilities detected. Immediate security review and patching required.",
                "action_items": [
                    "Review all critical and high severity findings",
                    "Apply security patches immediately",
                    "Consider taking affected systems offline if necessary"
                ]
            })
        
        # SSL/TLS recommendations
        ssl_issues = [issue for issue in security_issues if issue.get("type") == "ssl_config"]
        if ssl_issues:
            recommendations.append({
                "priority": "high",
                "category": "ssl_tls",
                "title": "SSL/TLS Configuration Issues",
                "description": "SSL/TLS configuration needs improvement",
                "action_items": [
                    "Implement HTTPS redirect",
                    "Update SSL/TLS certificates",
                    "Configure strong cipher suites"
                ]
            })
        
        # Security headers recommendations
        header_issues = [issue for issue in security_issues if issue.get("type") == "missing_header"]
        if header_issues:
            recommendations.append({
                "priority": "medium",
                "category": "security_headers",
                "title": "Missing Security Headers",
                "description": "Important security headers are missing",
                "action_items": [
                    "Implement Content Security Policy",
                    "Add X-Frame-Options header",
                    "Configure HSTS header"
                ]
            })
        
        return recommendations
